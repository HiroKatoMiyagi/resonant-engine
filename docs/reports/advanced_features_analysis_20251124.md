# Resonant Engine 高度機能分析レポート

**作成日**: 2025-11-24
**バージョン**: 1.0
**対象**: Resonant Engine v1.0 (Sprint 11完了時点)

---

## 概要

本レポートは、Resonant Engineに実装された6つの高度機能について、その**役割**・**解決する課題**・**動作原理**・**哲学との関連性**を解説します。

### 実装状況サマリー

| 機能 | 状態 | 達成度 |
|-----|------|-------|
| Contradiction Detection | 完全実装 | 100% |
| Choice Preservation | 完全実装 | 100% |
| Memory Lifecycle | 完全実装 | 100% |
| Re-evaluation Phase | 完全実装 | 90% |
| Temporal Constraint | 仕様完成 | 45% |
| Term Drift Detection | 仕様完成 | 0% |

---

## 1. Contradiction Detection（矛盾検出システム）

### 1.1 この機能が解決する課題

人間の意思決定には、**無意識の矛盾**が紛れ込むことがあります：

- 2週間前に「PostgreSQLを使う」と決めたのに、今日「SQLiteに変更」と言う
- 「マイクロサービス」で始めたのに、いつの間にか「モノリス」の話をしている
- 3ヶ月前にやった作業を忘れて、同じことをまたやろうとしている

これらの矛盾を**事前に検出**し、意識的に対処できるようにします。

### 1.2 動作の仕組み

```
新しいIntent（意図）が入力される
         ↓
    ┌───────────────────────────────────┐
    │    4層の検出パイプライン         │
    ├───────────────────────────────────┤
    │ 1. 技術スタック矛盾検出          │
    │    → 過去50件のIntentと技術選択を比較  │
    │                                   │
    │ 2. ポリシー転換検出              │
    │    → 14日以内のアーキテクチャ逆転を検出 │
    │                                   │
    │ 3. 重複作業検出                  │
    │    → Jaccard類似度85%以上で警告    │
    │                                   │
    │ 4. ドグマ検出                    │
    │    → 「絶対」「必ず」等の断定表現を検出 │
    └───────────────────────────────────┘
         ↓
    矛盾が検出された場合
         ↓
    ユーザーに3つの選択肢を提示：
    ├─ 方針変更として記録（意図的な転換）
    ├─ ミスとして修正（元に戻す）
    └─ 両方維持（共存可能と判断）
```

### 1.3 具体例

**技術スタック矛盾の例**:
```
過去: 「データベースはPostgreSQLで統一する」(3週間前)
今回: 「MongoDBを導入したい」

→ 警告: "TECH_STACK矛盾を検出しました"
   信頼度: 0.9
   関連Intent: intent_id_xxx (3週間前)
```

**ドグマ検出の例**:
```
入力: 「ユーザーは必ずログインしてから購入する」

→ 警告: "DOGMA検出 - 未検証の断定表現があります"
   対象語: 「必ず」
   推奨: 「通常は」「多くの場合」などの表現を検討
```

### 1.4 Resonant Engine哲学との関連

| 哲学原則 | この機能での実現 |
|---------|-----------------|
| **共鳴（Resonance）** | 新しい決定が過去の決定と「共鳴」しているかを検証。矛盾は共鳴の破れ |
| **呼吸（Breath）** | 急激なポリシー転換は「呼吸の乱れ」。14日ウィンドウで検出 |
| **選択肢保存** | 矛盾を「問題」ではなく「選択機会」として提示。ユーザーが決定権を持つ |

---

## 2. Choice Preservation（選択肢保存システム）

### 2.1 この機能が解決する課題

プロジェクトが進むにつれ、**過去の決定理由が失われる**問題があります：

- 「なぜ3ヶ月前にPostgreSQLを選んだんだっけ？」
- 「他にどんな選択肢を検討したか覚えていない」
- 「同じような判断を今また迫られているが、前回の経験を活かせない」

このシステムは、**決定ポイントと選択理由を構造的に記録**し、後から活用可能にします。

### 2.2 動作の仕組み

```
決定ポイントが発生
         ↓
    ChoicePoint（選択ポイント）を作成
    ├─ 質問: 「どのデータベースを使うか？」
    ├─ 選択肢:
    │   ├─ PostgreSQL (評価: 0.9, 選択済み)
    │   ├─ MySQL (評価: 0.7, 却下理由: "pgvector非対応")
    │   └─ MongoDB (評価: 0.5, 却下理由: "トランザクション弱い")
    ├─ タグ: ["technology_stack", "database"]
    └─ 決定理由: "ベクトル検索が必要なため"
         ↓
    データベースに保存
         ↓
    後日、類似の決定が必要になったとき
         ↓
    ChoiceQueryEngine が過去の決定を検索
    ├─ タグ検索: search_by_tags(["database"])
    ├─ 期間検索: search_by_time_range(30日)
    └─ 全文検索: search_fulltext("PostgreSQL")
         ↓
    Context Assembler が関連する過去の選択を自動注入
         ↓
    現在の決定が過去の知見を活かしたものになる
```

### 2.3 データ構造

```
ChoicePoint（選択ポイント）
├─ user_id: ユーザー識別子
├─ question: 「何を決めるのか」
├─ choices: 選択肢リスト（最低2つ）
│   ├─ choice_text: 選択肢の内容
│   ├─ selected: 選ばれたか
│   ├─ evaluation_score: 評価スコア (0-1)
│   └─ rejection_reason: 却下理由（選ばれなかった場合）
├─ tags: 分類タグ
├─ context_type: "architecture" | "feature" | "bug_fix"
├─ decision_rationale: 決定理由
├─ created_at: 作成日時
└─ decided_at: 決定日時
```

### 2.4 Resonant Engine哲学との関連

| 哲学原則 | この機能での実現 |
|---------|-----------------|
| **共鳴（Resonance）** | 過去の決定が現在の文脈に自動的に「共鳴」する。類似状況で過去の知見が浮上 |
| **呼吸（Breath）** | 各決定ポイントが「問い→選択肢検討→決定→振り返り」の呼吸サイクル |
| **選択肢保存** | **この機能の核心**。選択肢は「死んだ記録」ではなく「生きた知識」として保存 |

---

## 3. Memory Lifecycle Management（記憶ライフサイクル管理）

### 3.1 この機能が解決する課題

記憶（文脈情報）は無限に蓄積すると問題が発生します：

- 検索が遅くなる（10,000件の中から関連情報を探す）
- 古い情報がノイズになる（3年前の会話が今の判断を邪魔する）
- ストレージコストが増大する

このシステムは、**重要度の低い記憶を圧縮・アーカイブ**しながら、**重要な記憶を活性状態で維持**します。

### 3.2 動作の仕組み

```
記憶ストアの状態を監視
         ↓
    使用率が90%を超えた？
    ├─ No → 通常運用を継続
    └─ Yes → 圧縮プロセス開始
              ↓
         重要度スコアを計算
         ┌─────────────────────────────────┐
         │ 重要度 = 基本値 × 時間減衰 × アクセス加算 │
         │                                 │
         │ ・基本値: 0.5                   │
         │ ・時間減衰: 0.95^(経過週数)      │
         │   → 毎週5%ずつ減衰             │
         │ ・アクセス加算: 1 + 0.1×参照回数 │
         │   → 参照されるほど重要度維持    │
         └─────────────────────────────────┘
              ↓
         重要度 < 0.3 の記憶を抽出
              ↓
         Claude Haikuで要約圧縮
         ├─ 元: 「Xについての長い会話...」(500文字)
         └─ 圧縮後: 「Xの要件確認済み」(20文字)
              ↓
         アーカイブに保存
         ├─ 元の内容も保持（復元可能）
         ├─ 圧縮サマリーを保存
         └─ 圧縮率を記録（通常60-80%）
              ↓
         アクティブ記憶から削除
              ↓
         容量回復
```

### 3.3 重要度計算の例

```
例1: 4週間前の記憶、3回参照された
─────────────────────────────────
時間減衰: 0.95^4 ≒ 0.815
アクセス加算: min(1 + 0.3, 1.0) = 1.0
重要度: 0.5 × 0.815 × 1.0 = 0.41
→ 圧縮対象外（0.3以上）

例2: 8週間前の記憶、参照なし
─────────────────────────────────
時間減衰: 0.95^8 ≒ 0.663
アクセス加算: 1.0
重要度: 0.5 × 0.663 × 1.0 = 0.33
→ まだ圧縮対象外（境界付近）

例3: 12週間前の記憶、参照なし
─────────────────────────────────
時間減衰: 0.95^12 ≒ 0.540
アクセス加算: 1.0
重要度: 0.5 × 0.540 × 1.0 = 0.27
→ 圧縮対象（0.3未満）
```

### 3.4 Resonant Engine哲学との関連

| 哲学原則 | この機能での実現 |
|---------|-----------------|
| **共鳴（Resonance）** | 頻繁に参照される記憶は「共鳴度が高い」として維持。共鳴しない記憶は静かに退く |
| **呼吸（Breath）** | 記憶の減衰は自然な呼吸リズム。古い息は新しい息に場所を譲る |
| **認知管理** | 「認知過負荷」を防ぐ。必要な情報だけを活性化し、ノイズを減らす |

---

## 4. Re-evaluation Phase（再評価フェーズ）

### 4.1 この機能が解決する課題

Intentの処理後に**修正が必要**になることがあります：

- ユノ（思想層）からのフィードバック：「この方針は呼吸原則に反する」
- カナ（翻訳層）からのフィードバック：「技術的に実現困難」
- 要件の明確化：「ユーザーの意図を誤解していた」

このシステムは、**構造的な修正メカニズム**を提供し、修正履歴を保存します。

### 4.2 動作の仕組み

```
ユノまたはカナからフィードバック
         ↓
    ReEvaluationRequest 作成
    ├─ intent_id: 修正対象
    ├─ diff: 変更内容（絶対値のみ）
    ├─ source: "yuno" または "kana"（ツムは不可）
    └─ reason: 修正理由
         ↓
    バリデーション
    ├─ diff形式の検証
    ├─ ソース権限の確認（yuno/kanaのみ許可）
    └─ Intent状態の確認（修正可能か）
         ↓
    並行制御（楽観的ロック）
    ┌─ バージョン番号で競合検出
    ├─ 競合時は指数バックオフでリトライ
    └─ 失敗時は悲観的ロックにフォールバック
         ↓
    修正を適用
    ├─ correction_id を発行
    ├─ correction_history に追記
    ├─ applied_at タイムスタンプ
    └─ 監査ログに記録
         ↓
    冪等性チェック
    └─ 同じ修正が2回来ても1回だけ適用
```

### 4.3 修正リクエストの例

```json
{
  "intent_id": "550e8400-e29b-41d4-a716-446655440000",
  "diff": {
    "payload": {
      "feedback": {
        "yuno": {"status": "accepted"},
        "reason": "要件明確化後、承認"
      }
    }
  },
  "source": "yuno",
  "reason": "ユーザーとの対話で要件が明確になったため"
}
```

### 4.4 Resonant Engine哲学との関連

| 哲学原則 | この機能での実現 |
|---------|-----------------|
| **共鳴（Resonance）** | 修正により、Intentがシステム全体と再び「共鳴」する状態に戻る |
| **呼吸（Breath）** | 「検出→修正→再評価→継続」のミニ呼吸サイクル |
| **認知修正** | 誤解を「問題」ではなく「修正機会」として扱い、履歴を保存 |

---

## 5. Temporal Constraint Layer（時間的制約レイヤー）

### 5.1 この機能が解決する課題

テスト済みの安定したコードを**うっかり変更してしまう**リスクがあります：

- 50時間かけてテストした重要モジュール → 「ちょっとした修正」でテストが全部壊れる
- 再検証にまた50時間かかる
- どのコードが「安定」でどれが「実験的」か分からない

このシステムは、**検証済みファイルを保護**し、変更時に警告を出します。

### 5.2 動作の仕組み（設計）

```
ファイルのテストが完了
         ↓
    FileVerificationService.register_verification()
    ├─ file_path: "bridge/memory/service.py"
    ├─ test_hours: 12.5（投入時間）
    ├─ test_cases_count: 45（テストケース数）
    ├─ coverage_percent: 92.5%
    └─ expires_at: 3ヶ月後
         ↓
    ファイルが「保護対象」として登録
         ↓
    開発者がファイルを変更しようとする
         ↓
    check_file_modification() が呼ばれる
    ├─ 検証状態を確認
    ├─ 有効期限を確認
    ├─ 依存ファイルを分析
    └─ 影響範囲を推定
         ↓
    ⚠️ 警告を表示
    ├─ 「このファイルは12.5時間のテスト投資があります」
    ├─ 「8つのファイルがこれに依存しています」
    ├─ 「45のテストに影響する可能性があります」
    └─ 「再検証の推定時間: 8-10時間」
         ↓
    ユーザーが決定
    ├─ 変更をキャンセル
    ├─ 変更を続行（再検証が必要と記録）
    └─ 例外として許可（理由を記録）
```

### 5.3 想定されるデータ構造

```
FileVerification（ファイル検証記録）
├─ file_path: ファイルパス
├─ verification_status: "verified" | "unverified" | "expired"
├─ test_hours: テスト投入時間
├─ test_cases_count: テストケース数
├─ coverage_percent: カバレッジ率
├─ verified_at: 検証日時
├─ expires_at: 有効期限（デフォルト3ヶ月）
└─ verified_by: 検証者
```

### 5.4 Resonant Engine哲学との関連

| 哲学原則 | この機能での実現 |
|---------|-----------------|
| **共鳴（Resonance）** | 安定したコードはシステムと「共鳴」している。変更は共鳴を乱す可能性 |
| **呼吸（Breath）** | 検証時間は「投資された呼吸」。軽率な変更でその呼吸を無駄にしない |
| **選択肢保存** | 変更の「選択」を記録。強制ではなく警告として情報提供 |

---

## 6. Term Drift Detection（用語ドリフト検出）

### 6.1 この機能が解決する課題

プロジェクトが進むにつれ、**同じ言葉が違う意味で使われ始める**ことがあります：

- 1週目: 「ユーザー」= 登録済みアカウント保持者
- 8週目: 「ユーザー」= サイト訪問者全般（ゲスト含む）
- → 同じ言葉なのに意味が違う → 混乱とバグの原因

このシステムは、**用語の意味変化を検出**し、明示的に対処を促します。

### 6.2 動作の仕組み（設計）

```
プロジェクト用語を定義
         ↓
    TermRegistry.register_term()
    ├─ term: "ユーザー"
    ├─ definition: "登録済みのアカウントを持つ人物"
    ├─ scope: "global"（全体適用）
    └─ aliases: ["User", "アカウント", "メンバー"]
         ↓
    新しいIntentやコードが投入される
         ↓
    TermDriftDetector.detect_drift()
    ├─ 用語の使用箇所を検出
    ├─ 周辺文脈（50単語）を抽出
    ├─ 定義との整合性を比較
    └─ 意味のずれスコアを計算（0-1）
         ↓
    ドリフト指標をチェック
    ├─ 「拡張」: "含む", "including" → 定義より広い
    ├─ 「制限」: "のみ", "限定" → 定義より狭い
    └─ 「変更」: "新しい", "変更後の" → 根本的な変化
         ↓
    ⚠️ 用語ドリフト警告
    ├─ 「'ユーザー'の使い方が定義と異なります」
    ├─ 検出文脈: 「ユーザーの行動を追跡（ゲスト含む）」
    ├─ 登録定義: 「登録済みのアカウントを持つ人物」
    └─ 意味ずれスコア: 0.65（高い乖離）
         ↓
    ユーザーが決定
    ├─ 定義を更新: 「ゲストも含む」に変更
    ├─ 別の用語を使用: 「訪問者」に変更
    └─ 例外として許可: 文脈限定の使用として記録
```

### 6.3 想定されるデータ構造

```
TermDefinition（用語定義）
├─ term: 用語
├─ definition: 定義
├─ scope: "global" | "module" | "file"
├─ version: バージョン番号
├─ aliases: 別名リスト
└─ superseded_by: 新バージョンへの参照

TermDriftAlert（ドリフト警告）
├─ term_id: 対象用語
├─ alert_type: "definition_drift" | "context_mismatch" | "alias_conflict"
├─ severity: "info" | "warning" | "critical"
├─ detected_context: 検出された文脈
├─ expected_definition: 期待される定義
└─ semantic_diff_score: 意味ずれスコア
```

### 6.4 Resonant Engine哲学との関連

| 哲学原則 | この機能での実現 |
|---------|-----------------|
| **共鳴（Resonance）** | 共通言語は共鳴の基盤。言葉の意味がずれると共鳴も乱れる |
| **呼吸（Breath）** | 用語のドリフトは「呼吸の乱れ」のサイン。立ち止まって言葉を整える |
| **認知の一貫性** | 用語ドリフトは明示的な認知的不整合。検出して解消すべき |

---

## 6つの機能の相互作用

### 統合アーキテクチャ

```
                 Intent入力
                     ↓
    ┌────────────────────────────────────┐
    │      Intent処理パイプライン        │
    │                                    │
    │  [1] Contradiction Detection       │
    │      → 過去との矛盾をチェック      │
    │              ↓                     │
    │  [2] Term Drift Detection          │
    │      → 用語の意味ずれをチェック    │
    │              ↓                     │
    │  [3] Choice Preservation Query     │
    │      → 関連する過去の選択を取得    │
    │              ↓                     │
    │  [4] Memory Lifecycle Check        │
    │      → 記憶容量と重要度を管理      │
    │              ↓                     │
    │  [5] Re-evaluation Phase           │
    │      → 必要に応じて修正を適用      │
    │              ↓                     │
    │  [6] Temporal Constraint Check     │
    │      → 検証済みコードへの影響を警告 │
    │              ↓                     │
    │      Intent処理実行                │
    │              ↓                     │
    │      ChoicePoint作成               │
    │              ↓                     │
    │      Memory保存                    │
    │              ↓                     │
    │      必要に応じて圧縮              │
    └────────────────────────────────────┘
```

### 哲学原則との対応マトリクス

| 機能 | 共鳴 | 呼吸 | 選択肢保存 |
|-----|:---:|:---:|:---:|
| **Contradiction Detection** | 不整合検出 | 急激な変化を検出 | 過去の選択を参照 |
| **Choice Preservation** | 過去が現在に共鳴 | 決定サイクル | **核心機能** |
| **Memory Lifecycle** | 共鳴する記憶を維持 | 自然な減衰リズム | 復元可能な圧縮 |
| **Re-evaluation Phase** | 修正で共鳴回復 | ミニ呼吸サイクル | 修正履歴を保存 |
| **Temporal Constraint** | 安定コードの保護 | 投資の尊重 | 変更選択を記録 |
| **Term Drift Detection** | 共通言語の維持 | 言葉の乱れを検出 | 用語履歴を保存 |

---

## まとめ

Resonant Engineの6つの高度機能は、以下の目的を達成するために連携しています：

### 1. カオスの防止
- **Contradiction Detection**: 無意識の矛盾を検出
- **Term Drift Detection**: 言葉の意味ずれを検出
- **Temporal Constraint**: 安定コードの軽率な変更を防止

### 2. 履歴の保存
- **Choice Preservation**: 決定と理由を構造的に記録
- **Memory Lifecycle**: 重要な記憶を維持しつつ圧縮で効率化

### 3. 修正の可能性
- **Re-evaluation Phase**: 間違いを優雅に修正できる仕組み

### 4. ユーザー主権の尊重
- すべての機能が**警告と選択肢**を提供
- 強制ではなく情報提供
- 「否定しない。呼吸を整える。」の原則を実現

これらの機能は、Resonant Engineの核心思想である「**理解とは模倣ではなく共鳴**」を技術的に実現しています。

---

**ドキュメント作成者**: Claude Code
**最終更新**: 2025-11-24
