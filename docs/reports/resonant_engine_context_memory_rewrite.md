# Resonant Engine — Context & Memory Architecture (Rewritten)

## 目的
Resonant Engine は「思考の補助」ではなく、**時間軸・理由・状態遷移を失わないための構造**として設計される。
本書は、ChatGPT / Claude / Claude Code / Cursor / Copilot / Kiro における
**コンテキスト管理・メモリ管理の実態差**を前提に、
Resonant Engine が担うべき責務を再定義する。

---

## 1. 根本的な分岐：記憶の置き場所

### サーバ記憶型（人格的メモリ）
対象：ChatGPT / Claude（Chat）

- 記憶はベンダー管理サーバに保存
- 会話ログから意味を抽出・圧縮
- 理由・検討過程・状態遷移は保持されない
- ユーザーは直接編集・検証できない

**結論**
> 会話の自然さは高いが、設計・検証・再現には使えない

---

### ファイル記憶型（システムメモリ）
対象：Claude Code / Kiro / Cursor / Copilot

- 永続したい情報はローカルファイルに保存
- Git 管理・レビュー・差分追跡が可能
- 起動時に自動ロードされる設計が主流

**結論**
> 記憶は「資産」であり、構造化されるべきもの

---

## 2. 各ツールの思想的位置づけ

### Kiro
- 会話メモリを持たない
- 信頼対象は `.kiro/steering` と `.kiro/specs`
- Specs は **機能単位・フェーズ単位**で永続
- 会話は UI に過ぎず、終了時に破棄される

**思想**
> 思考を信じない。仕様と状態だけを信じる。

---

### Claude Code
- CLAUDE.md を中核とした永続メモリ
- セッション・チェックポイントを 30 日保持
- /resume /rewind により時間軸を復元可能
- 会話とコードの両方を「履歴」として扱う

**思想**
> 会話・実装・判断を時間として保持する。

---

### Cursor / Copilot
- 現在開いているファイル中心
- 生産性最適化が主目的
- 長期的理由や設計履歴は外部依存

**思想**
> 今の作業を速くするための文脈保持。

---

## 3. 自動読み込みの重要性

Resonant Engine が重視するのは以下：

- 起動時に **人の意識を介さず** 効くこと
- 再説明を必要としないこと
- 状態が必ず外部に残ること

この条件を満たすのは、
- Kiro の Steering / Specs
- Claude Code の CLAUDE.md / rules

であり、**会話記憶では代替できない**。

---

## 4. Resonant Engine の責務再定義

Resonant Engine は以下を担う：

1. **Intent の永続化**
   - なぜそれを選んだのか
   - 何と比較したのか

2. **Choice / Alternative の保存**
   - 却下案を含む意思決定構造

3. **State Transition の記録**
   - 決定 → 修正 → 再評価の履歴

4. **AI ツール非依存**
   - 記憶は常にファイル
   - AI は参照者であって保管者ではない

---

## 5. 三層構造の再整理

### L3：思想・原則層（Yuno）
- 原則・哲学・規範
- 変更頻度は低い
- ファイルで永続

### L2：翻訳・設計層（Kana）
- Intent → 構造化
- 判断理由の明文化
- Re-evaluation を実行

### L1：実装・具現層（Tsumu）
- コード生成・編集
- 揮発的
- 成果のみを L2 に還元

---

## 6. 結論

- 会話は記憶に向かない
- 記憶は必ずファイルに落とす
- 自動ロードされない記憶は、存在しないのと同じ

**Resonant Engine は、AI の限界を補うための
「時間と理由を失わない構造体」である。**
