<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Project Tree Viewer — 折りたたみ表示</title>
<style>
  :root { --bg:#0f1115; --fg:#e6e6e6; --muted:#9aa0a6; --accent:#4c8bf5; --chip:#1b1f2a; --border:#2a2f3a; }
  html,body{height:100%;}
  body{
    margin:0; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic UI", "Meiryo", Arial, sans-serif;
    background:var(--bg); color:var(--fg);
    display:flex; flex-direction:column;
  }
  header{
    padding:16px 20px; border-bottom:1px solid var(--border);
    display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:space-between;
  }
  .left, .right{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
  h1{font-size:16px; margin:0; color:#fff; letter-spacing:.2px;}
  input[type="text"]{width:280px; max-width:55vw; padding:10px 12px; border-radius:8px; border:1px solid var(--border); background:#0b0d12; color:var(--fg); outline:none;}
  input[type="text"]::placeholder{color:var(--muted);}
  button{
    border:1px solid var(--border); background:#121722; color:var(--fg); padding:10px 12px; border-radius:8px; cursor:pointer;
  }
  button:hover{background:#171c28;}
  .pill{padding:8px 10px; border-radius:999px; background:var(--chip); border:1px solid var(--border); color:var(--muted); font-size:12px;}
  .dropzone{
    margin:14px 20px; padding:16px; border:1px dashed var(--border); border-radius:10px; color:var(--muted);
  }
  .dropzone.drag{border-color:var(--accent); color:#cde; background:#0c1324;}
  .grid{display:grid; grid-template-columns: 1fr; gap:0;}
  #tree{padding:10px 18px 50px;}
  ul.tree{list-style:none; padding-left:14px; margin:0;}
  li.item{margin:2px 0; position:relative; padding-left:22px;}
  li.item .twist{position:absolute; left:0; top:2px; width:18px; height:18px; display:inline-grid; place-items:center; font-size:12px; color:var(--muted); cursor:pointer; user-select:none;}
  li.item.file .twist{opacity:.35; cursor:default;}
  li.item .name{cursor:default;}
  li.item.dir > .name{cursor:pointer;}
  li.item .name mark{background:transparent; color:#ffd479; font-weight:600;}
  li.item.collapsed > ul{display:none;}
  .counts{margin-left:6px; color:var(--muted); font-size:12px;}
  footer{position:sticky; bottom:0; background:linear-gradient(180deg, rgba(15,17,21,0), rgba(15,17,21,.95)); padding:14px 20px; border-top:1px solid var(--border);}
  .hint{color:var(--muted); font-size:12px;}
  .kbd{border:1px solid var(--border); background:#0b0d12; padding:1px 6px; border-radius:6px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px;}
  .hidden{display:none!important;}
</style>
</head>
<body>
  <header>
    <div class="left">
      <h1>Project Tree Viewer <span class="pill">折りたたみ・検索対応</span></h1>
      <span class="counts" id="counts">—</span>
    </div>
    <div class="right">
      <input id="q" type="text" placeholder="検索（ファイル/フォルダ名）… / を押してフォーカス">
      <button id="expandAll">すべて展開</button>
      <button id="collapseAll">すべて折りたたみ</button>
      <button id="copyHtml">HTMLをコピー</button>
      <label class="pill">
        <input id="toggleFiles" type="checkbox" checked>
        <span style="margin-left:6px;">ファイルも表示</span>
      </label>
    </div>
  </header>

  <div class="dropzone" id="drop">
    ⬇️ ここに <b>project_tree.txt</b> をドラッグ＆ドロップ、またはクリックして選択／下のテキストへ貼り付け。<br>
    対応形式：<code>tree</code> コマンド出力（├── / └── / │）またはインデント階層リスト。
  </div>

  <div class="grid">
    <div id="tree"></div>
  </div>

  <footer>
    <div class="hint">
      <b>使い方：</b> 1) ファイルをドロップ or 貼り付け → 2) クリックで折りたたみ/展開 → 3) <span class="kbd">E</span>で展開 / <span class="kbd">C</span>で折りたたみ / <span class="kbd">/</span>で検索。<br>
      検索はハイライト＆一致ノードまで展開。HTML出力は現在の展開状態を含みません（構造のみ）。
    </div>
  </footer>

<script>
// ---------- Utilities ----------
function byId(id){return document.getElementById(id)}
const drop = byId('drop');
const out = byId('tree');
const q = byId('q');
const expandBtn = byId('expandAll');
const collapseBtn = byId('collapseAll');
const copyBtn = byId('copyHtml');
const toggleFiles = byId('toggleFiles');
const countsEl = byId('counts');

function normalizeLine(line){
  // Strip tree-drawing characters and normalize indent
  // Examples: "│   ├── src", "    └── file.txt", "├── dir"
  const replaced = line
    .replace(/[│]/g, '│')  // keep to help depth calc
    .replace(/├──|└──/g, '') // remove branch symbols
    .replace(/\s+$/,'');     // rtrim
  return replaced;
}

function depthOf(line){
  // Count groups of 4 spaces or '│   ' before visible name
  // Approach: scan from start to first non [' ', '│'] then compute blocks of 4 spaces and '│   '.
  let i=0, depth=0;
  while(i < line.length){
    if(line.startsWith('    ', i)){ depth++; i+=4; continue; }
    if(line.startsWith('│   ', i)){ depth++; i+=4; continue; }
    if(line[i]===' ' || line[i]==='│'){ i++; continue; }
    break;
  }
  return depth;
}

function visibleName(line){
  // After trimming prefixes, what's left is the label
  // Remove leading spaces and any stray branch glyphs
  return line.replace(/^[\s│]+/, '').replace(/^[├└]──\s*/, '').trim();
}

function isProbablyDir(name){
  // Heuristic: has trailing '/', or no '.' in last path segment
  if(name.endsWith('/')) return true;
  const base = name.split('/').pop();
  return !base.includes('.');
}

function parseTreeText(text){
  const lines = text.split(/\r?\n/).filter(l => l.trim().length>0);
  const root = { name: '(root)', children: [], dir:true };
  const stack = [ { node: root, depth: -1 } ];

  for(const raw of lines){
    const line = normalizeLine(raw);
    const d = depthOf(line);
    const name = visibleName(line);
    if(!name) continue;

    const node = { name, children: [], dir: isProbablyDir(name) };

    // adjust stack to current depth
    while(stack.length && stack[stack.length-1].depth >= d){
      stack.pop();
    }
    stack[stack.length-1].node.children.push(node);
    stack.push({ node, depth: d });
  }
  return root;
}

function buildList(node, { filter='', showFiles=true }){
  // Returns <ul> element
  const ul = document.createElement('ul');
  ul.className = 'tree';

  function matches(name){
    return filter ? name.toLowerCase().includes(filter.toLowerCase()) : true;
  }

  function dfs(n){
    if(n === rootModel) { // skip synthetic root label
      n.children.forEach(dfs);
      return;
    }
    if(!n.dir && !showFiles) return; // hide files
    const li = document.createElement('li');
    li.className = 'item ' + (n.dir ? 'dir' : 'file');

    const twist = document.createElement('span');
    twist.className = 'twist';
    twist.textContent = n.dir ? '▸' : '•';

    const nameEl = document.createElement('span');
    nameEl.className = 'name';
    nameEl.textContent = n.name;

    // Search highlight
    if(filter && matches(n.name)){
      const idx = n.name.toLowerCase().indexOf(filter.toLowerCase());
      if(idx >= 0){
        const before = n.name.slice(0, idx);
        const mid = n.name.slice(idx, idx+filter.length);
        const after = n.name.slice(idx+filter.length);
        nameEl.innerHTML = `${escapeHtml(before)}<mark>${escapeHtml(mid)}</mark>${escapeHtml(after)}`;
      }
    }

    if(n.dir){
      li.appendChild(twist);
      li.appendChild(nameEl);
      const childUl = document.createElement('ul');
      childUl.className = 'tree';
      n.children.forEach(c => {
        const childLi = dfs(c);
        if(childLi) childUl.appendChild(childLi);
      });
      li.appendChild(childUl);
      // Default expanded
      li.classList.remove('collapsed');
      twist.addEventListener('click', () => toggle(li));
      nameEl.addEventListener('click', () => toggle(li));
    }else{
      li.appendChild(twist);
      li.appendChild(nameEl);
    }

    // Filter visibility: show nodes that match or have matching descendants
    if(filter){
      const selfMatch = matches(n.name);
      const descMatch = !!li.querySelector('mark');
      if(!selfMatch && !descMatch && !n.dir) return null;
      // Expand parents when filter active
      if(n.dir && (selfMatch || descMatch)) li.classList.remove('collapsed');
    }

    return li;
  }

  function toggle(li){
    const isCollapsed = li.classList.toggle('collapsed');
    const twist = li.querySelector('.twist');
    if(!twist) return;
    twist.textContent = isCollapsed ? '▸' : '▾';
  }

  function escapeHtml(s){
    return s.replace(/[&<>"']/g, c => ({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
    }[c]));
  }

  const frag = document.createDocumentFragment();
  const liList = [];
  rootModel.children.forEach(c => {
    const li = dfs(c);
    if(li) liList.push(li);
  });
  liList.forEach(li => frag.appendChild(li));
  ul.appendChild(frag);
  return ul;
}

// ---------- UI State ----------
let rootModel = { name:'(root)', dir:true, children:[] };

function render(){
  out.innerHTML = '';
  const filter = q.value.trim();
  const showFiles = toggleFiles.checked;
  const ul = buildList(rootModel, { filter, showFiles });
  out.appendChild(ul);
  updateCounts();
  // Set twist symbols for initial state
  out.querySelectorAll('li.item.dir').forEach(li => {
    const twist = li.querySelector('.twist'); if(!twist) return;
    const collapsed = li.classList.contains('collapsed');
    twist.textContent = collapsed ? '▸' : '▾';
  });
}

function updateCounts(){
  const totalDirs = countBy(n => n.dir);
  const totalFiles = countBy(n => !n.dir);
  countsEl.textContent = `フォルダ ${totalDirs}・ファイル ${totalFiles}`;
}

function countBy(pred){
  let cnt=0;
  (function walk(n){
    if(n!==rootModel && pred(n)) cnt++;
    n.children?.forEach(walk);
  })(rootModel);
  return cnt;
}

function setFromText(text){
  rootModel = parseTreeText(text);
  render();
}

// ---------- Interactions ----------
expandBtn.addEventListener('click', () => {
  out.querySelectorAll('li.item.dir').forEach(li => li.classList.remove('collapsed'));
  out.querySelectorAll('li.item.dir .twist').forEach(t => t.textContent='▾');
});

collapseBtn.addEventListener('click', () => {
  out.querySelectorAll('li.item.dir').forEach(li => li.classList.add('collapsed'));
  out.querySelectorAll('li.item.dir .twist').forEach(t => t.textContent='▸');
});

copyBtn.addEventListener('click', () => {
  const html = out.innerHTML;
  navigator.clipboard.writeText(html).then(()=>{
    copyBtn.textContent = 'コピーしました';
    setTimeout(()=>copyBtn.textContent='HTMLをコピー', 1200);
  });
});

toggleFiles.addEventListener('change', render);

q.addEventListener('input', render);
q.addEventListener('keydown', (e)=>{
  if(e.key==='Escape'){ q.value=''; render(); }
});

window.addEventListener('keydown', (e)=>{
  if(e.key==='/'){ e.preventDefault(); q.focus(); q.select(); }
  if(e.key==='e' || e.key==='E'){ expandBtn.click(); }
  if(e.key==='c' || e.key==='C'){ collapseBtn.click(); }
});

// Drag & drop + click
drop.addEventListener('dragover', (e)=>{ e.preventDefault(); drop.classList.add('drag'); });
drop.addEventListener('dragleave', ()=> drop.classList.remove('drag'));
drop.addEventListener('drop', async (e)=>{
  e.preventDefault(); drop.classList.remove('drag');
  const f = e.dataTransfer.files?.[0];
  if(f){
    const text = await f.text();
    setFromText(text);
  }
});

drop.addEventListener('click', async ()=>{
  const inp = document.createElement('input');
  inp.type = 'file'; inp.accept = '.txt,.log,.md,text/plain';
  inp.onchange = async () => {
    const f = inp.files?.[0]; if(!f) return;
    const text = await f.text();
    setFromText(text);
  };
  inp.click();
});

// Paste support
window.addEventListener('paste', (e)=>{
  const text = e.clipboardData?.getData('text/plain');
  if(text && text.split(/\r?\n/).length>1){
    setFromText(text);
  }
});

// Demo placeholder
setFromText(`src
├── app/
│   ├── main.py
│   └── utils/
│       └── helper.py
├── README.md
└── tests/
    └── test_main.py`);
</script>
</body>
</html>
